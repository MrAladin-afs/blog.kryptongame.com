---
import type { ServerProduct } from "@/lib/handlers/serverProducts";
import { serverProductsHandler } from "@/lib/handlers/serverProducts";

type Props = {
  products: ServerProduct[];
  autoplay?: boolean;
  interval?: number;
};

const { products, autoplay = true, interval = 5000 } = Astro.props;
---

<section class="server-product-slider container mx-auto mt-8 mb-8">
  <div
    class="relative w-full overflow-hidden rounded-lg cursor-grab active:cursor-grabbing"
    data-server-slider="true"
    data-autoplay={autoplay.toString()}
    data-interval={interval.toString()}
  >
    <!-- Slider wrapper -->
    <div class="relative h-64 md:h-96 lg:h-[500px] overflow-hidden rounded-lg">
      {
        products.map((product, index) => (
          <div
            class={`absolute top-0 left-0 w-full h-full transition-opacity duration-700 ease-in-out ${
              index === 0 ? 'opacity-100 z-20' : 'opacity-0 z-10'
            }`}
            data-slide={index}
          >
            <!-- Background Image -->
            <div class="absolute inset-0 z-0 zoom-container">
              <img
                src={product.image}
                alt={product.title}
                class="w-full h-full object-cover zoom-image transition-transform duration-300 ease-out"
                loading={index === 0 ? "eager" : "lazy"}
                decoding="async"
                fetchpriority={index === 0 ? "high" : "low"}
              />
              <div class="absolute inset-0 bg-gradient-to-r from-black/70 via-black/50 to-transparent"></div>
            </div>
            
            <!-- Content Overlay -->
            <div class="absolute inset-0 z-10 flex items-center justify-center">
              <div class="text-center px-4">
                <div class="mb-6">
                  <span class="bg-purple-500 px-4 py-2 rounded-full text-white font-medium text-sm">
                    {product.category}
                  </span>
                </div>
                
                <h1 class="text-2xl md:text-4xl lg:text-5xl xl:text-6xl font-bold font-serif mb-8 leading-tight text-white max-w-4xl mx-auto">
                  <a 
                    href={product.link}
                    target="_blank"
                    class="hover:underline underline-offset-4 decoration-2"
                  >
                    {product.title}
                  </a>
                </h1>
                
                <div class="mt-8">
                  <a
                    href={product.link}
                    target="_blank"
                    class="inline-flex items-center px-8 py-4 bg-purple-500 text-white font-medium rounded-lg hover:bg-purple-600 transition-colors duration-200 text-lg"
                  >
                    View Product
                    <svg class="ml-2 w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
                    </svg>
                  </a>
                </div>
              </div>
            </div>
          </div>
        ))
      }
    </div>

    <!-- Navigation Dots -->
    <div class="absolute bottom-4 left-1/2 transform -translate-x-1/2 z-30">
      <div class="flex space-x-2">
        {
          products.map((_, index) => (
            <button
              type="button"
              class={`w-3 h-3 rounded-full transition-all duration-300 ${
                index === 0 
                  ? "bg-purple-400 scale-110" 
                  : "bg-white/50 hover:bg-white/75"
              }`}
              aria-current={index === 0}
              aria-label={`Go to slide ${index + 1}`}
              data-slide-indicator={index}
            />
          ))
        }
      </div>
    </div>

    <!-- Navigation Arrows -->
    <button
      type="button"
      class="absolute top-1/2 left-4 transform -translate-y-1/2 z-30 p-2 rounded-full bg-white/20 hover:bg-white/30 backdrop-blur-sm transition-all duration-200 group"
      data-slide-prev
      aria-label="Previous slide"
    >
      <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path>
      </svg>
    </button>

    <button
      type="button"
      class="absolute top-1/2 right-4 transform -translate-y-1/2 z-30 p-2 rounded-full bg-white/20 hover:bg-white/30 backdrop-blur-sm transition-all duration-200 group"
      data-slide-next
      aria-label="Next slide"
    >
      <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
      </svg>
    </button>
  </div>
</section>

<script>
  class ServerProductSlider {
    private slider: HTMLElement;
    private slides: NodeListOf<HTMLElement>;
    private indicators: NodeListOf<HTMLButtonElement>;
    private prevButton: HTMLButtonElement;
    private nextButton: HTMLButtonElement;
    private currentSlide: number = 0;
    private autoplayInterval: NodeJS.Timeout | null = null;
    private isAutoplay: boolean;
    private interval: number;
    private isDragging: boolean = false;
    private dragStartX: number = 0;
    private dragStartY: number = 0;

    constructor(slider: HTMLElement) {
      this.slider = slider;
      this.slides = slider.querySelectorAll('[data-slide]');
      this.indicators = slider.querySelectorAll('[data-slide-indicator]');
      this.prevButton = slider.querySelector('[data-slide-prev]')!;
      this.nextButton = slider.querySelector('[data-slide-next]')!;
      this.isAutoplay = slider.dataset.autoplay === 'true';
      this.interval = parseInt(slider.dataset.interval || '5000');

      this.init();
    }

    private init() {
      this.prevButton.addEventListener('click', () => this.prevSlide());
      this.nextButton.addEventListener('click', () => this.nextSlide());
      
      this.indicators.forEach((indicator, index) => {
        indicator.addEventListener('click', () => this.goToSlide(index));
      });

      this.slider.addEventListener('mouseenter', () => this.pauseAutoplay());
      this.slider.addEventListener('mouseleave', () => this.startAutoplay());

      // Simplified drag events
      this.slider.addEventListener('mousedown', (e) => this.handleMouseDown(e));
      this.slider.addEventListener('mousemove', (e) => this.handleMouseMove(e));
      this.slider.addEventListener('mouseup', () => this.handleMouseUp());
      this.slider.addEventListener('mouseleave', () => this.handleMouseUp());

      this.slider.addEventListener('touchstart', (e) => this.handleTouchStart(e));
      this.slider.addEventListener('touchmove', (e) => this.handleTouchMove(e));
      this.slider.addEventListener('touchend', () => this.handleMouseUp());

      if (this.isAutoplay) {
        this.startAutoplay();
      }
    }

    private handleMouseDown(e: MouseEvent) {
      this.isDragging = true;
      this.dragStartX = e.clientX;
      this.dragStartY = e.clientY;
      this.slider.style.cursor = 'grabbing';
    }

    private handleMouseMove(e: MouseEvent) {
      if (!this.isDragging) return;

      const deltaX = e.clientX - this.dragStartX;
      const deltaY = e.clientY - this.dragStartY;
      const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
      
      const maxDistance = 100;
      const zoomFactor = Math.min(1 + (distance / maxDistance) * 0.3, 1.3);
      
      const currentSlideElement = this.slides[this.currentSlide];
      const zoomImage = currentSlideElement.querySelector('.zoom-image') as HTMLElement;
      
      if (zoomImage) {
        zoomImage.style.transform = `scale(${zoomFactor})`;
      }
    }

    private handleMouseUp() {
      if (!this.isDragging) return;
      
      this.isDragging = false;
      this.slider.style.cursor = 'grab';
      
      const currentSlideElement = this.slides[this.currentSlide];
      const zoomImage = currentSlideElement.querySelector('.zoom-image') as HTMLElement;
      
      if (zoomImage) {
        zoomImage.style.transform = 'scale(1)';
      }
    }

    private handleTouchStart(e: TouchEvent) {
      if (e.touches.length === 1) {
        this.isDragging = true;
        this.dragStartX = e.touches[0].clientX;
        this.dragStartY = e.touches[0].clientY;
      }
    }

    private handleTouchMove(e: TouchEvent) {
      if (!this.isDragging || e.touches.length !== 1) return;

      const deltaX = e.touches[0].clientX - this.dragStartX;
      const deltaY = e.touches[0].clientY - this.dragStartY;
      const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
      
      const maxDistance = 100;
      const zoomFactor = Math.min(1 + (distance / maxDistance) * 0.3, 1.3);
      
      const currentSlideElement = this.slides[this.currentSlide];
      const zoomImage = currentSlideElement.querySelector('.zoom-image') as HTMLElement;
      
      if (zoomImage) {
        zoomImage.style.transform = `scale(${zoomFactor})`;
      }
    }

    private goToSlide(index: number) {
      if (index === this.currentSlide) return;
      
      // Reset zoom on slide change
      this.slides[this.currentSlide].querySelector('.zoom-image')?.style.setProperty('transform', 'scale(1)');
      
      // Hide current slide
      this.slides[this.currentSlide].classList.remove('opacity-100', 'z-20');
      this.slides[this.currentSlide].classList.add('opacity-0', 'z-10');
      this.indicators[this.currentSlide].classList.remove('bg-purple-400', 'scale-110');
      this.indicators[this.currentSlide].classList.add('bg-white/50');
      this.indicators[this.currentSlide].setAttribute('aria-current', 'false');

      // Show new slide
      this.currentSlide = index;
      this.slides[this.currentSlide].classList.remove('opacity-0', 'z-10');
      this.slides[this.currentSlide].classList.add('opacity-100', 'z-20');
      this.indicators[this.currentSlide].classList.remove('bg-white/50');
      this.indicators[this.currentSlide].classList.add('bg-purple-400', 'scale-110');
      this.indicators[this.currentSlide].setAttribute('aria-current', 'true');
    }

    private nextSlide() {
      const nextIndex = (this.currentSlide + 1) % this.slides.length;
      this.goToSlide(nextIndex);
    }

    private prevSlide() {
      const prevIndex = (this.currentSlide - 1 + this.slides.length) % this.slides.length;
      this.goToSlide(prevIndex);
    }

    private startAutoplay() {
      if (this.isAutoplay && !this.autoplayInterval) {
        this.autoplayInterval = setInterval(() => {
          this.nextSlide();
        }, this.interval);
      }
    }

    private pauseAutoplay() {
      if (this.autoplayInterval) {
        clearInterval(this.autoplayInterval);
        this.autoplayInterval = null;
      }
    }
  }

  // Initialize all server product sliders
  document.addEventListener('DOMContentLoaded', () => {
    const sliders = document.querySelectorAll('[data-server-slider]');
    sliders.forEach(slider => {
      new ServerProductSlider(slider as HTMLElement);
    });
  });
</script>

<style>
  .zoom-container {
    overflow: hidden;
  }

  .zoom-image {
    transform-origin: center center;
    will-change: transform;
  }

  /* Smooth cursor transitions */
  [data-server-slider] {
    transition: cursor 0.2s ease;
  }

  /* Prevent text selection during drag */
  [data-server-slider].dragging {
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
  }
</style>
