---
import type { ServerProduct } from "@/lib/handlers/serverProducts";
import { serverProductsHandler } from "@/lib/handlers/serverProducts";

type Props = {
  products: ServerProduct[];
  autoplay?: boolean;
  interval?: number;
};

const { products, autoplay = true, interval = 5000 } = Astro.props;
---

<section class="server-product-slider container mx-auto mt-8 mb-8">
  <div
    class="relative w-full overflow-hidden rounded-lg cursor-grab active:cursor-grabbing"
    data-server-slider="true"
    data-autoplay={autoplay.toString()}
    data-interval={interval.toString()}
  >
    <!-- Slider wrapper -->
    <div class="relative h-64 md:h-96 lg:h-[500px] overflow-hidden rounded-lg">
      {
        products.map((product, index) => (
          <div
            class={`absolute top-0 left-0 w-full h-full transition-opacity duration-700 ease-in-out ${
              index === 0 ? 'opacity-100 z-20' : 'opacity-0 z-10'
            }`}
            data-slide={index}
            style={`transform: translateZ(0); ${index === 0 ? '' : 'pointer-events: none;'}`}
          >
            <!-- Background Image -->
            <div class="absolute inset-0 z-0 zoom-container">
              <img
                src={product.image}
                alt={product.title}
                class="w-full h-full object-cover zoom-image transition-transform duration-300 ease-out"
                loading={index === 0 ? "eager" : "lazy"}
                decoding={index === 0 ? "sync" : "async"}
                fetchpriority={index === 0 ? "high" : "low"}
              />
              <div class="absolute inset-0 bg-gradient-to-r from-black/70 via-black/50 to-transparent"></div>
            </div>
            
            <!-- Content Overlay -->
            <div class="absolute inset-0 z-10 flex items-center justify-center">
              <div class="text-center px-4">
                <div class="mb-6">
                  <span class="bg-purple-500 px-4 py-2 rounded-full text-white font-medium text-sm">
                    {product.category}
                  </span>
                </div>
                
                <h1 class="text-2xl md:text-4xl lg:text-5xl xl:text-6xl font-bold font-serif mb-8 leading-tight text-white max-w-4xl mx-auto">
                  <a 
                    href={product.link}
                    target="_blank"
                    class="hover:underline underline-offset-4 decoration-2"
                  >
                    {product.title}
                  </a>
                </h1>
                
                <div class="mt-8">
                  <a
                    href={product.link}
                    target="_blank"
                    class="inline-flex items-center px-8 py-4 bg-purple-500 text-white font-medium rounded-lg hover:bg-purple-600 transition-colors duration-200 text-lg"
                  >
                    View Product
                    <svg class="ml-2 w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
                    </svg>
                  </a>
                </div>
              </div>
            </div>
          </div>
        ))
      }
    </div>

    <!-- Navigation Dots -->
    <div class="absolute bottom-4 left-1/2 transform -translate-x-1/2 z-30">
      <div class="flex space-x-2">
        {
          products.map((_, index) => (
            <button
              type="button"
              class={`w-3 h-3 rounded-full transition-all duration-300 ${
                index === 0 
                  ? "bg-purple-400 scale-110" 
                  : "bg-white/50 hover:bg-white/75"
              }`}
              aria-current={index === 0}
              aria-label={`Go to slide ${index + 1}`}
              data-slide-indicator={index}
            />
          ))
        }
      </div>
    </div>

    <!-- Navigation Arrows -->
    <button
      type="button"
      class="absolute top-1/2 left-4 transform -translate-y-1/2 z-30 p-2 rounded-full bg-white/20 hover:bg-white/30 backdrop-blur-sm transition-all duration-200 group"
      data-slide-prev
      aria-label="Previous slide"
    >
      <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path>
      </svg>
    </button>

    <button
      type="button"
      class="absolute top-1/2 right-4 transform -translate-y-1/2 z-30 p-2 rounded-full bg-white/20 hover:bg-white/30 backdrop-blur-sm transition-all duration-200 group"
      data-slide-next
      aria-label="Next slide"
    >
      <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
      </svg>
    </button>
  </div>
</section>

<script>
  class OptimizedServerProductSlider {
    private slider: HTMLElement;
    private slides: HTMLElement[];
    private indicators: HTMLButtonElement[];
    private prevButton: HTMLButtonElement;
    private nextButton: HTMLButtonElement;
    private currentSlide: number = 0;
    private autoplayInterval: number | null = null;
    private isAutoplay: boolean;
    private interval: number;
    private isTransitioning: boolean = false;
    private isDragging: boolean = false;
    private dragStartX: number = 0;
    private dragStartY: number = 0;
    private rafId: number | null = null;
    private eventListeners: Array<{ element: EventTarget; event: string; handler: EventListener }> = [];

    constructor(slider: HTMLElement) {
      this.slider = slider;
      this.slides = Array.from(slider.querySelectorAll('[data-slide]'));
      this.indicators = Array.from(slider.querySelectorAll('[data-slide-indicator]'));
      this.prevButton = slider.querySelector('[data-slide-prev]')!;
      this.nextButton = slider.querySelector('[data-slide-next]')!;
      this.isAutoplay = slider.dataset.autoplay === 'true';
      this.interval = parseInt(slider.dataset.interval || '5000');

      this.init();
    }

    private init() {
      // Navigation events
      this.addEventListener(this.prevButton, 'click', () => this.prevSlide());
      this.addEventListener(this.nextButton, 'click', () => this.nextSlide());
      
      this.indicators.forEach((indicator, index) => {
        this.addEventListener(indicator, 'click', () => this.goToSlide(index));
      });

      // Autoplay controls
      this.addEventListener(this.slider, 'mouseenter', () => this.pauseAutoplay(), { passive: true });
      this.addEventListener(this.slider, 'mouseleave', () => this.startAutoplay(), { passive: true });

      // Optimized drag events with throttling
      this.addEventListener(this.slider, 'mousedown', (e) => this.handleMouseDown(e));
      this.addEventListener(this.slider, 'mousemove', (e) => this.handleMouseMove(e), { passive: true });
      this.addEventListener(this.slider, 'mouseup', () => this.handleMouseUp());
      this.addEventListener(this.slider, 'mouseleave', () => this.handleMouseUp());

      // Touch events
      this.addEventListener(this.slider, 'touchstart', (e) => this.handleTouchStart(e), { passive: true });
      this.addEventListener(this.slider, 'touchmove', (e) => this.handleTouchMove(e), { passive: true });
      this.addEventListener(this.slider, 'touchend', () => this.handleMouseUp());

      if (this.isAutoplay) {
        this.startAutoplay();
      }
    }

    private addEventListener(element: EventTarget, event: string, handler: EventListener, options?: AddEventListenerOptions) {
      element.addEventListener(event, handler, options);
      this.eventListeners.push({ element, event, handler });
    }

    private handleMouseDown(e: MouseEvent) {
      this.isDragging = true;
      this.dragStartX = e.clientX;
      this.dragStartY = e.clientY;
      this.slider.style.cursor = 'grabbing';
    }

    private handleMouseMove(e: MouseEvent) {
      if (!this.isDragging) return;

      // Throttle with requestAnimationFrame
      if (this.rafId) return;
      
      this.rafId = requestAnimationFrame(() => {
        const deltaX = e.clientX - this.dragStartX;
        const deltaY = e.clientY - this.dragStartY;
        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        
        const maxDistance = 100;
        const zoomFactor = Math.min(1 + (distance / maxDistance) * 0.3, 1.3);
        
        const currentSlideElement = this.slides[this.currentSlide];
        const zoomImage = currentSlideElement.querySelector('.zoom-image') as HTMLElement;
        
        if (zoomImage) {
          zoomImage.style.transform = `scale(${zoomFactor})`;
        }
        
        this.rafId = null;
      });
    }

    private handleMouseUp() {
      if (!this.isDragging) return;
      
      this.isDragging = false;
      this.slider.style.cursor = 'grab';
      
      if (this.rafId) {
        cancelAnimationFrame(this.rafId);
        this.rafId = null;
      }
      
      // Reset zoom
      const currentSlideElement = this.slides[this.currentSlide];
      const zoomImage = currentSlideElement.querySelector('.zoom-image') as HTMLElement;
      
      if (zoomImage) {
        zoomImage.style.transform = 'scale(1)';
      }
    }

    private handleTouchStart(e: TouchEvent) {
      if (e.touches.length === 1) {
        this.isDragging = true;
        this.dragStartX = e.touches[0].clientX;
        this.dragStartY = e.touches[0].clientY;
      }
    }

    private handleTouchMove(e: TouchEvent) {
      if (!this.isDragging || e.touches.length !== 1) return;

      // Throttle with requestAnimationFrame
      if (this.rafId) return;
      
      this.rafId = requestAnimationFrame(() => {
        const deltaX = e.touches[0].clientX - this.dragStartX;
        const deltaY = e.touches[0].clientY - this.dragStartY;
        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        
        const maxDistance = 100;
        const zoomFactor = Math.min(1 + (distance / maxDistance) * 0.3, 1.3);
        
        const currentSlideElement = this.slides[this.currentSlide];
        const zoomImage = currentSlideElement.querySelector('.zoom-image') as HTMLElement;
        
        if (zoomImage) {
          zoomImage.style.transform = `scale(${zoomFactor})`;
        }
        
        this.rafId = null;
      });
    }

    private goToSlide(index: number) {
      if (this.isTransitioning || index === this.currentSlide) return;
      
      this.isTransitioning = true;
      
      // Reset zoom on slide change
      const currentSlideElement = this.slides[this.currentSlide];
      const zoomImage = currentSlideElement.querySelector('.zoom-image') as HTMLElement;
      if (zoomImage) {
        zoomImage.style.transform = 'scale(1)';
      }
      
      requestAnimationFrame(() => {
        const newSlideEl = this.slides[index];
        const currentIndicator = this.indicators[this.currentSlide];
        const newIndicator = this.indicators[index];

        // Batch DOM updates
        currentSlideElement.style.opacity = '0';
        currentSlideElement.style.pointerEvents = 'none';
        currentSlideElement.style.zIndex = '10';
        
        newSlideEl.style.opacity = '1';
        newSlideEl.style.pointerEvents = 'auto';
        newSlideEl.style.zIndex = '20';

        // Update indicators
        currentIndicator.classList.remove('bg-purple-400', 'scale-110');
        currentIndicator.classList.add('bg-white/50');
        currentIndicator.setAttribute('aria-current', 'false');

        newIndicator.classList.remove('bg-white/50');
        newIndicator.classList.add('bg-purple-400', 'scale-110');
        newIndicator.setAttribute('aria-current', 'true');

        this.currentSlide = index;
        
        setTimeout(() => {
          this.isTransitioning = false;
        }, 700);
      });
    }

    private nextSlide() {
      const nextIndex = (this.currentSlide + 1) % this.slides.length;
      this.goToSlide(nextIndex);
    }

    private prevSlide() {
      const prevIndex = (this.currentSlide - 1 + this.slides.length) % this.slides.length;
      this.goToSlide(prevIndex);
    }

    private startAutoplay() {
      if (this.isAutoplay && !this.autoplayInterval) {
        this.autoplayInterval = window.setInterval(() => {
          this.nextSlide();
        }, this.interval);
      }
    }

    private pauseAutoplay() {
      if (this.autoplayInterval) {
        clearInterval(this.autoplayInterval);
        this.autoplayInterval = null;
      }
    }

    public destroy() {
      this.pauseAutoplay();
      if (this.rafId) {
        cancelAnimationFrame(this.rafId);
      }
      this.eventListeners.forEach(({ element, event, handler }) => {
        element.removeEventListener(event, handler);
      });
      this.eventListeners = [];
    }
  }

  // Initialize all server product sliders with cleanup
  const sliders = new Map<HTMLElement, OptimizedServerProductSlider>();
  
  document.addEventListener('DOMContentLoaded', () => {
    const sliderElements = document.querySelectorAll('[data-server-slider]');
    sliderElements.forEach(slider => {
      const sliderInstance = new OptimizedServerProductSlider(slider as HTMLElement);
      sliders.set(slider as HTMLElement, sliderInstance);
    });
  });

  // Cleanup on page unload
  window.addEventListener('beforeunload', () => {
    sliders.forEach(slider => slider.destroy());
    sliders.clear();
  });
</script>

<style>
  .zoom-container {
    overflow: hidden;
  }

  .zoom-image {
    transform-origin: center center;
    will-change: transform;
  }

  /* Performance optimizations */
  [data-server-slider] {
    contain: layout style paint;
    transition: cursor 0.2s ease;
  }

  [data-server-slider] [data-slide] {
    will-change: opacity;
    backface-visibility: hidden;
    transform: translateZ(0);
  }

  [data-server-slider] [data-slide] img {
    will-change: auto;
  }

  /* Prevent text selection during drag */
  [data-server-slider].dragging {
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
  }
</style>
